<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[成绩分析系统（Javafx）]]></title>
    <url>%2F2018%2F01%2F09%2Fcjfx%2F</url>
    <content type="text"><![CDATA[简易成绩分析系统 成绩分析系统（Javafx）写在前面最近闲着无聊，研究了一下用javafx的scenebuilder怎么写一些简易的程序，发现开发起来真的很容易，界面只要直接拖拉，只要自己用它提供的接口把功能补齐就好了，大大地缩短了开发时间，因此在这里给各位老铁一个简易的成绩分析系统提供使用参考。 软件介绍程序可以动态分析用户提供的数据，实时修改统计表也能动态改变算是这个系统最大的卖点，同时，可以在表格里直接双击编辑成绩，并且表格可以自动排序（这个是javafx自带的功能）。不得不说，因为这些功能，做开发的时候是缩短了许多时间。同时，我也自己加了一些功能，例如直接可以查询表格里面的某些关键字，筛选出自己想找的某些人，然后可以即可修改他们的成绩（修改后返回全部人的表格的时候，会发现他们的成绩也会同步改变），方便用户操作，以及如果已存在该班该课程的成绩单，会提醒已经存在，是否覆盖，以防数据丢失。可以说是一个能实际应用的小程序了。 主界面 修改操作 统计图动态改变 实时查询 防止覆盖提醒 下载戳这(附源码)]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建立属于自己的私人网盘]]></title>
    <url>%2F2017%2F11%2F13%2Fbuildseafile%2F</url>
    <content type="text"><![CDATA[建立Seafile网盘教程 Windows建立方法写在前面由于博主最近服务器有点多，于是就弄了个seafile来玩玩，谁知道一玩之下才发现，原来seafile使用起来是这么便捷！ Seafile介绍这是我见过的第一款有客户端，网页版的私人网盘，关键是可以在线预览修改代码，并支持多人同时修改，留言，所以，它可以作为很好的一个多人合作的平台。 同时，它可以自动备份历史版本的文件！ 当然，它还可以选择性共享给用户组，或者单独用户，甚至可以申请一个上传链接，让人免登陆把文件传到自己的文件夹里，这个功能也是得点赞，不过它作为客户端可以变成一个挂载盘，这样让我们使用起来更加方便了~！(PS: APP的功能也有照片自动备份等等)]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后缀自动机]]></title>
    <url>%2F2017%2F09%2F18%2Fhzzdj%2F</url>
    <content type="text"><![CDATA[待更新…]]></content>
  </entry>
  <entry>
    <title><![CDATA[优酷爱奇艺会员电影教程]]></title>
    <url>%2F2017%2F09%2F16%2Fykhy%2F</url>
    <content type="text"><![CDATA[某些特殊的操作技巧！ 想免费看会员电影吗？ 无意中发现一个网站，可以免费看优酷爱奇艺会员电影，或者是想免广告，都可以用哦~ 以优酷会员电影为例 我想看这部电影，首先要点进去这部电影，然后复制链接~ 之后打开这个链接→点我 把复制好的链接粘贴在这里 输入223366 最后尽情享受吧~]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
        <tag>Video</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客小挂件]]></title>
    <url>%2F2017%2F08%2F20%2Fbkgj%2F</url>
    <content type="text"><![CDATA[博客中的小插件分享 博客小插件 小插件简介这个网站是作者的博客，主要是针对google小工具模块而开发的，使用起来很简单，只要将代码复制到博客的源码(html)模式下就可以实现挂件展示啦。。。你可以# 养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，是很讨人喜欢的博客装饰。。。 传送门 使用方法选择一个你喜欢的挂件，页面会提供一组代码，将它们复制粘贴至你博客的源码(html)模式下即可。 同类型网站，留着备用Crazy ProfileMySpace网站相关头像、图标、模板、挂件，除了模板，其它的都可通用。（网友一见钟情提供） ——34-97-F6-72-6F-1E]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨平台便签]]></title>
    <url>%2F2017%2F08%2F12%2Ft%2F</url>
    <content type="text"><![CDATA[跨平台便签共享 安利一发便利的便签网址 电脑到手机 安卓到苹果 想要快速的传输网站或文本，只需要用这个跨平台便签，一键粘贴，巨方便！！！（室友做的安利一发） 点这里 代码粘贴网址: 点这里]]></content>
      <categories>
        <category>Tool</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敌兵布阵]]></title>
    <url>%2F2017%2F07%2F17%2Fdbbz%2F</url>
    <content type="text"><![CDATA[树状数组 敌兵布阵 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 85661 Accepted Submission(s): 36126 问题描述C国的死对头A国这段时间正在进行军事演习，所以C国间谍头子Derek和他手下Tidy又开始忙乎了。A国在海岸线沿直线布置了N个工兵营地,Derek和Tidy的任务就是要监视这些工兵营地的活动情况。由于采取了某种先进的监测手段，所以每个工兵营地的人数C国都掌握的一清二楚,每个工兵营地的人数都有可能发生变动，可能增加或减少若干人手,但这些都逃不过C国的监视。中央情报局要研究敌人究竟演习什么战术,所以Tidy要随时向Derek汇报某一段连续的工兵营地一共有多少人,例如Derek问:“Tidy,马上汇报第3个营地到第10个营地共有多少人!”Tidy就要马上开始计算这一段的总人数并汇报。但敌兵营地的人数经常变动，而Derek每次询问的段都不一样，所以Tidy不得不每次都一个一个营地的去数，很快就精疲力尽了，Derek对Tidy的计算速度越来越不满:”你个死肥仔，算得这么慢，我炒你鱿鱼!”Tidy想：“你自己来算算看，这可真是一项累人的工作!我恨不得你炒我鱿鱼呢!”无奈之下，Tidy只好打电话向计算机专家Windbreaker求救,Windbreaker说：“死肥仔，叫你平时做多点acm题和看多点算法书，现在尝到苦果了吧!”Tidy说：”我知错了。。。”但Windbreaker已经挂掉电话了。Tidy很苦恼，这么算他真的会崩溃的，聪明的读者，你能写个程序帮他完成这项工作吗？不过如果你的程序效率不够高的话，Tidy还是会受到Derek的责骂的. Input第一行一个整数T，表示有T组数据。每组数据第一行一个正整数N（N&lt;=50000）,表示敌人有N个工兵营地，接下来有N个正整数,第i个正整数ai代表第i个工兵营地里开始时有ai个人（1&lt;=ai&lt;=50）。接下来每行有一条命令，命令有4种形式：(1) Add i j,i和j为正整数,表示第i个营地增加j个人（j不超过30）(2)Sub i j ,i和j为正整数,表示第i个营地减少j个人（j不超过30）;(3)Query i j ,i和j为正整数,i&lt;=j，表示询问第i到第j个营地的总人数;(4)End 表示结束，这条命令在每组数据最后出现;每组数据最多有40000条命令 Output对第i组数据,首先输出“Case i:”和回车,对于每个Query询问，输出一个整数并回车,表示询问的段中的总人数,这个数保持在int以内。 Sample Input1101 2 3 4 5 6 7 8 9 10Query 1 3Add 3 6Query 2 7Sub 10 2Add 6 3Query 3 10End Sample OutputCase 1:63359 代码123456789101112#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;set&gt;#include&lt;stack&gt;#include&lt;map&gt;using namespace std; 123456#define rep(i,a,n) for(i=a; i&lt;n; i++)#define rep1(i,a,n) for(i=n-1; i&gt;=a; i--)#define ll long long#define mem(a) memset(a,0,sizeof(a))#define memb(a) memset(a,false,sizeof(a))#define INF 0x3f3f3f3f 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int a[50005];int n;int lowbit(int i)&#123; return i&amp;(-i);&#125;void update(int i,int v)&#123; while(i&lt;=n) &#123; a[i]+=v; i+=lowbit(i); &#125;&#125;int sum(int i)&#123; int ans=0; while(i&gt;0) &#123; ans+=a[i]; i-=lowbit(i); &#125; return ans;&#125;int main()&#123;#ifdef test freopen("in.txt","r",stdin);#endif int casen,t=1,i,j,temp,num; string s; scanf("%d",&amp;casen); while(casen--) &#123; mem(a); scanf("%d",&amp;n); rep(i,1,n+1) &#123; scanf("%ld",&amp;temp); update(i,temp); &#125; printf("Case %d:\n",t); cin &gt;&gt; s; while(s!="End") &#123; if(s=="Add") &#123; scanf("%d%d",&amp;i,&amp;num); update(i,num); &#125; else if(s=="Query") &#123; scanf("%d%d",&amp;i,&amp;j); temp=sum(j)-sum(i-1); printf("%d\n",temp); &#125; else if(s=="Sub") &#123; scanf("%d%d",&amp;i,&amp;num); update(i,-num); &#125; cin &gt;&gt; s; &#125; t++; &#125; return 0;&#125; 写在最后记得清空数组]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>problem solve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邝斌的ACM模板]]></title>
    <url>%2F2017%2F07%2F17%2Fkuangbin%2F</url>
    <content type="text"><![CDATA[在线预览以及下载 资源分享：邝斌的模板下载地址:点这里]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包九讲]]></title>
    <url>%2F2017%2F07%2F17%2Fbbjj%2F</url>
    <content type="text"><![CDATA[背包九讲 资源分享：背包九讲下载地址:点这里]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shadowsocks的简单介绍]]></title>
    <url>%2F2017%2F07%2F01%2Fshadowsocks%2F</url>
    <content type="text"><![CDATA[在VPN即将被封的情况下，我们要怎么继续翻墙 用Shadowsocks的简易教程先做一个比较简单的新手帖，毕竟博主也是刚接触这没多久，各位大佬请轻喷 故事背景GFW对于VPN的封杀无时无刻不在进行，最典型的就是GFW早已可以准确识别OpenVPN，原理是利用协议在握手阶段的某些特征来检测，从而可以达成瞬间阻断OpenVPN连接，很有可能你连第一次连接都连不上就被检测到了。而且这还没完，你胆敢用OpenVPN的后果，就是服务器IP立马被照顾，所有不能被识别的加密流量均会被阻断。所以现在使用VPN，不能使用原生的OpenVPN。必须使用变式的OpenVPN或者其他类的VPN软件。比如说给流量做混淆，再比如使用GFW目前无法识别的VPN，比如：SoftEther VPN。 GFW对于VPN是坚决封杀的，目前引入的流量检测技术，识别流量类型，导致很多VPN都跪了。加之目前的“有罪推定”这一蛋疼的方式，导致一切加密手段都变成了浮云。无论你使用多复杂的加密手段都没用，GFW会认为所有他认不出来的加密浏览都是“犯罪嫌疑人”，并对这些流量进行监控。如果满足一定的条件，GFW将会判定“罪名成立”并处“暂时截断所有不能识别的加密浏览”等类似处罚，也就是“死缓”，如果屡教不改者判以“死刑立即执行”，予以永久封IP处罚。 总之能代理就先代理，代理不行再挂VPN，VPN要少用，万一被检测出来，后果很严重。。说不定你花钱买的VPN就这么跪了，钱就白瞎进去了。 shadowsocks介绍shadowsocks是一款轻量级socks5代理，在安卓机子上很出名。使用Linux服务器做代理，必须有国外代理服务器，手机版提供了一个公共代理，速度尚可。 注意，注意！！也就是说，当你发现你手机提供的公共代理是能让你翻墙的，如果对速度没有过多要求，你就可以不用再看部署教程了！ 优点：使用完整Linux服务器代理而不是GAE这种功能受限的Web host，shadowsocks可以完整代理你所有类型的流量。跨平台，主流操作系统均有支持的客户端。 缺点：受限于代理服务器的连接速度，除非你使用离你所在地距离较近的国外代理服务器，否则速度上很难达到goagent的速度。 部署教程服务端部分 首先你需要有一台在国外，也就是不会被墙的服务器，那么这些服务器大都比较廉价，而想要找到一台物美价廉的则需要你耐心去等待啦，这里博主分享的是搬瓦工的服务器。（PS：请翻墙后点开链接） 在注册完账号和选择好自己想要的配置之后，购买完毕，就可以开始部署了~（PS：配置就看一下是多少个人用的吧，一般小水管也能在Youtube上看看视频的。) 先在SERVERICE里面找到自己刚刚购买的服务器，然后选KiwiVM进入界面 在这里，我们可以选择让自己的服务器定位在哪里，当然地方不一样，网速体验也不一样 然后，我们可以在shadsocks server里面，找到自己服务器ss的password，还有IP以及端口。 那么，我们的服务端就搞定了~ 客户端部分先下载shadowsocksWindows版Mac版Andorid版iOS请直接应用商店搜索 Wingy（免费）或者Shadowrocket(收费)或者Potatso（收费） 博主比较懒，因此只用Windows版做例子，其他包括手机也是同样方法配置就好 首先，运行shadsocks 选择服务器一栏，编辑服务器 按照在服务器上面已经填好的配置，依次填入IP，端口，密码，验证方式，其他可以自动忽略，然后点击添加 系统代理模式可以选择PAC模式（就是它会智能识别，是用你的代理上某个网站快，还是直接上这个网站快），或者全局模式（PAC上不了的网就直接换全局，全部走代理来上，一般问题都能解决） 最后就可以尽情享受翻墙的乐趣啦~ 写在最后用了代理来翻墙，我们是会有流量加密的，也就是说，GFW是看不到你在上什么网站的（嘿嘿），那么如果你想知道连着自己的代理的人在上什么网站，你也可以去自己的服务器上看（嘿嘿），最后，别忘了给你的服务器续费哦~]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>application</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL之优先队列]]></title>
    <url>%2F2017%2F06%2F14%2Fpriority-queue%2F</url>
    <content type="text"><![CDATA[优先队列简单教程 STL之优先队列写在前面先做一个超级简单的新手帖，教教大家怎么正确的使用STL里面的优先队列priority_queue. 简介priority_queue是STL里面事先已经实现好的堆排序，构成了一个可以直接输出最大值或者最小值，查询时间只需要O(logn)的调用函数，它的基本语句如下 priority_queue]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据恢复]]></title>
    <url>%2F2017%2F06%2F14%2Fsjhf%2F</url>
    <content type="text"><![CDATA[数据恢复教程 数据恢复写在前面由于博主今天要恢复一些被误删了的文件，特地花了一个下午去找免费，有效的数据恢复软件，皇天不负有心人，不少文件都被抢救回来了，但是还有很多没有T T 注意事项 1.在文件被误删后，立刻停止对该盘的读写操作，要保证文件不会被覆盖损坏掉，不然神仙也救不了！2.找到有用的恢复文件进行恢复，不要用一些三流软件，很容易让你被删除的文件损坏掉！ 软件介绍1. 都叫兽下载链接 这款软件能恢复50M以内的文件（免费版），一些比较简单的小文件可以直接下载这个恢复 2. 7-Data下载链接 这款是企业版的破解版，就可以无限使用，而且恢复也可能比都叫兽会有用 3. DiskGeniusPro专业版下载链接 *这款博主并未使用过，但是看起来效果不错，所以也推上来了。 写在最后其实只要平时做好数据备份和保护，根本用不上这个贴，当然，最坏情况如果真的出现了，也要保持冷静，因为不管怎么样，还是会有希望的存在的！ 希望这能帮助到你~]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hdu-1024 Max Sum Plus Plus]]></title>
    <url>%2F2017%2F06%2F06%2Fhdu-1024%2F</url>
    <content type="text"><![CDATA[基础dp以及优化 Max Sum Plus Plus 原题链接：https://vjudge.net/contest/165707#problem/A 问题描述Now I think you have got an AC in Ignatius.L’s “Max Sum” problem. To be a brave ACMer, we always challenge ourselves to more difficult problems. Now you are faced with a more difficult problem. Given a consecutive number sequence S 1, S 2, S 3, S 4 … S x, … S n (1 ≤ x ≤ n ≤ 1,000,000, -32768 ≤ S x ≤ 32767). We define a function sum(i, j) = S i + … + S j (1 ≤ i ≤ j ≤ n). Now given an integer m (m &gt; 0), your task is to find m pairs of i and j which make sum(i 1, j 1) + sum(i 2, j 2) + sum(i 3, j 3) + … + sum(i m, j m) maximal (i x ≤ i y ≤ j x or i x ≤ j y ≤ j x is not allowed). But I`m lazy, I don’t want to write a special-judge module, so you don’t have to output m pairs of i and j, just output the maximal summation of sum(i x, j x)(1 ≤ x ≤ m) instead. 题意【问题描述】—-最大M子段和问题给定由 n个整数（可能为负整数）组成的序列a1，a2，a3，……，an，以及一个正整数 m，要求确定序列 a1，a2，a3，……，an的 m个不相交子段，使这m个子段的总和达到最大，求出最大和。 InputEach test case will begin with two integers m and n, followed by n integers S 1, S 2, S 3 … S n.Process to the end of file. OutputOutput the maximal summation described above in one line. Sample Input1 3 1 2 32 6 -1 4 -2 3 -2 3 Sample Output68 题解这里因为是最大问题，很容易联想到是dp做法。但是要怎么写状态转移方程呢？首先，我们可以发现，对于一个子问题而言，在j个数里面选i个字段做为最优解就可以了，那么细化到最后就是只有一个数，选一个字段，那对于下一状态来说，就是j+1这个数，是并入到j-1里面，还是独立一个字段的问题。所以状态转移方程为dp[i][j]=max(dp[i-1][t],dp[i][j-1])+a[j]; 其中（1&lt;=t&lt;=j-1),所以接下来我们要做的就是怎么去实现这个方程。由于方程里的dp[i-1][t]数组，如果每次都要重新找一次，那么时间复杂度就是O(mn²）远远超出了时间限制，因此我们需要优化。①优化时间在这里，我们可以发现，每个位置的dp[i-1][t]都是从它上一位置维护出来的，因此我们只需要用一个一维数组——maxn[]去维护这个dp[i-1][t]，其中maxn[j-1]就是表示j位的dp[i-1][t],因此方程变成了dp[i][j]=max(maxn[j-1],dp[i][j-1])+a[j];②优化空间我们知道了j的范围（即n）是1e6，可是没有给i（即m）的范围，因此，如果m超过了100，我们的dp[][]就会爆内存了，所以我们需要优化空间。在这里，手动模拟一遍，我们可以发现对于每一个dp[i][j]，它的dp[i][j-1]要么就是dp[i-1][t]，要么就是前i个数全部选择了，然后从i+1一直到j-1连续了过来。为什么是i？因为在第i层，我们需要构造i个字段，那么dp[][]这个数组也不需要存在了，直接用一个临时变量tmp就可以替换了。tmp表示dp[i][j-1]，所以现在的方程变成了*tmp=max(maxn[j-1],tmp)+a[j]; 代码里面最难理解的就是maxn这个数组怎么维护了，接下来可以边看我代码边看这边的解释，看多几遍估计就能理解了。（PS： maxn数组与代码中的dp数组是同一个数组，而代码里我的下标是从0开始的，所以读者可以自行缩减一位，当然这里有个坑，容我迟点再说）因为对于maxn这个数组来说，maxn[n]是永远不会用到的，因此它可以用来做临时储存变量。那么对每一层的maxn来说，它是用来维护下一层的tmp的，然后tmp又会用来维护它自己那层的maxn，所以我们是先用了maxn当前的值维护tmp，再用把这个maxn变成新的维护好的值。所以这里maxn[n]的作用就体现出来了，对j-1来说，它通过一次维护，可以得到一个新的maxn[j-1]，然而当前的maxn[j-1]对这层的j是有用的，因此我们把新的maxn[j-1]先暂时存放到maxn[n]里面，然后再在tmp在第j位用完了旧的maxn[j-1]（上一层维护出来的）后，再把maxn[n]赋给maxn[j-1]，为下一层做准备。 代码123456789101112131415#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;cstdlib&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;cstdlib&gt;using namespace std; 12345678#define mem(a) memset(a,0,sizeof(a))#define rep(i,a,n) for(int i=a; i&lt;n; i++)#define rep1(i,a,n) for(int i=n-1; i&gt;=a; i--)#define s(a) scanf("%d",&amp;a)#define sll(a) scanf("%lld",&amp;a)#define test(a) cout&lt;&lt;a&lt;&lt;endl#define test2(a,b) cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl#define IOS ios::sync_with_stdio(false);cin.tie(0) 123456typedef long long ll;const int MAX = 1016;const int N = 1e6+10;const int INF = 0x3f3f3f3f;const int mod = 1e9+7;ll a[N],dp[N]; 1234567891011121314151617181920212223242526272829int main()&#123; int n,m; while(scanf("%d%d",&amp;m,&amp;n)!=EOF) &#123; rep(i,0,n) &#123; sll(a[i]); &#125; mem(dp); rep(i,0,m) &#123; ll tmp=0; rep(j,0,i+1) &#123; tmp+=a[j]; &#125; dp[n-1]=tmp; rep(j,i+1,n) &#123; tmp=max(dp[j-1],tmp)+a[j]; dp[j-1]=dp[n-1]; dp[n-1]=max(dp[n-1],tmp); &#125; &#125; cout &lt;&lt; dp[n-1] &lt;&lt; endl; &#125; return 0;&#125; 写在最后这里面我wa了好几次，最后在认真模拟后找到了原因，因为我的下标是从0开始的，那么对于只有一个字段的时候来说，初始的tmp是要把第一个数加进去的然而我并没有加，导致了最后一直wa。]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>problem solve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ-2236 Wireless Network]]></title>
    <url>%2F2017%2F05%2F31%2FPOJ-2236%2F</url>
    <content type="text"><![CDATA[简单并查集题解 Wireless Network 原题链接：https://vjudge.net/contest/165746#problem/A 问题描述An earthquake takes place in Southeast Asia. The ACM (Asia Cooperated Medical team) have set up a wireless network with the lap computers, but an unexpected aftershock attacked, all computers in the network were all broken. The computers are repaired one by one, and the network gradually began to work again. Because of the hardware restricts, each computer can only directly communicate with the computers that are not farther than d meters from it. But every computer can be regarded as the intermediary of the communication between two other computers, that is to say computer A and computer B can communicate if computer A and computer B can communicate directly or there is a computer C that can communicate with both A and B. In the process of repairing the network, workers can take two kinds of operations at every moment, repairing a computer, or testing if two computers can communicate. Your job is to answer all the testing operations. 题意有n台电脑，给出这n台电脑的坐标，所有电脑的初始状态全部是断电的，电脑与电脑之间如果要直接相连，必须是距离相差在最大范围d以内。现在进行一系列操作，按要求输出。操作一共有2种：1.开启一台电脑的电源。2.查询两台电脑是否能相互联系（直接、间接），若能，则输出SUCCESS，若不能，则输出FAIL。 InputThe first line contains two integers N and d (1 &lt;= N &lt;= 1001, 0 &lt;= d &lt;= 20000). Here N is the number of computers, which are numbered from 1 to N, and D is the maximum distance two computers can communicate directly. In the next N lines, each contains two integers xi, yi (0 &lt;= xi, yi &lt;= 10000), which is the coordinate of N computers. From the (N+1)-th line to the end of input, there are operations, which are carried out one by one. Each line contains an operation in one of following two formats: “O p” (1 &lt;= p &lt;= N), which means repairing computer p. “S p q” (1 &lt;= p, q &lt;= N), which means testing whether computer p and q can communicate. The input will not exceed 300000 lines. OutputFor each Testing operation, print “SUCCESS” if the two computers can communicate, or “FAIL” if not. Sample Input4 10 10 20 30 4O 1O 2O 4S 1 4O 3S 1 4 Sample OutputFAILSUCCESS 题解 题意很简单，就是一个普通的并查集，我们要做的就是每次激活了一台电脑就从1-n扫一次，找到激活了，而且在它距离里的电脑，跟它做一次并查集。当然，这里的并查集做了优化，就是同时指向了它的最高级祖先，这样做的效果就是8秒的程序2秒跑完了。 代码123456789101112131415#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;cstdlib&gt;#include&lt;stack&gt;#include&lt;bitset&gt;#include&lt;cstdlib&gt;using namespace std; 123456#define mem(a) memset(a,0,sizeof(a))#define rep(i,a,n) for(int i=a; i&lt;n; i++)#define rep1(i,a,n) for(int i=n-1; i&gt;=a; i--)#define s(a) scanf("%d",&amp;a)#define test(a) cout&lt;&lt;a&lt;&lt;endl#define test2(a,b) cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl 123456typedef long long ll;const int MAX = 1016;const int MAX = 1016;const int N = 1e3+10;const int INF = 0x3f3f3f3f;const int mod = 1e9+7; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int a[N][2],v[N],f[N];int d;int calculate(int x1,int x2,int y1,int y2)&#123; return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);&#125;int find_father(int x)&#123; int root=x,temp; while(f[root]!=root) root=f[root]; while(f[x]!=x) &#123; temp=x; x=f[x]; f[temp]=root; &#125; return x;&#125;void combine_father(int i,int x)&#123; if(calculate(a[i][0],a[x][0],a[i][1],a[x][1])&gt;d*d) return; x=find_father(x); i=find_father(i); if(i!=x) f[x]=i;&#125;int main()&#123; mem(v); mem(a); int n; char choice; scanf("%d%d",&amp;n,&amp;d); rep(i,0,n) &#123; scanf("%d%d",&amp;a[i][0],&amp;a[i][1]); f[i]=i; &#125; getchar(); while(scanf("%c",&amp;choice)!=EOF) &#123; if(choice=='S') &#123; int x,y; scanf("%d%d",&amp;x,&amp;y); x--; y--; getchar(); if(find_father(x)==find_father(y)) cout &lt;&lt; "SUCCESS" &lt;&lt; endl; else cout &lt;&lt; "FAIL" &lt;&lt; endl; &#125; else &#123; int x; s(x); x--; getchar(); v[x]=true; rep(i,0,n) if(i!=x&amp;&amp;v[i]) combine_father(i,x); &#125; &#125; return 0;&#125; 写在最后 #define IOS ios::sync_with_stdio(false);cin.tie(0) 这句就是让我在这题里wa了5次的罪归祸首!!! 其实这句话是为了能让cin的扫入方式改变，然后它的速度就能媲美scanf，然而，因为它的存在，scanf和printf就不能使用了，否则会出现bug！！所以一句话，早用scanf，早accepted.]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>problem solve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路算法(2)]]></title>
    <url>%2F2017%2F05%2F31%2Fdij-dui%2F</url>
    <content type="text"><![CDATA[dijkstra+优先队列（小顶堆） Dijkstra(O(mlogn))算法叙述有了链式前向星，再来看Dijkstra算法，我们关注算法的第3)步，对和x直接相邻的点进行更新的时候，不再需要遍历所有的点，而是只更新和x直接相邻的点，这样总的更新次数就和顶点数n无关了，总更新次数就是总边数m，算法的复杂度变成了O(n²+m)，之前的复杂度是O(n²)，但是有两个n²的操作，而这里是一个，原因在于找d值最小的顶点的时候还是一个O(n)的轮询，总共n次查找。那么查找d值最小有什么好办法呢？数据结构中有一种树，它能够在O(log(n))的时间内插入和删除数据，并且在O(1)的时间内得到当前数据的最小值，这个和我们的需求不谋而合，它就是最小二叉堆(小顶堆)，具体实现不讲了，比较简单，可以参考堆排序。在C++中，可以利用STL的优先队列(priority_queue)来实现获取最小值的操作，这里直接给出利用优先队列优化的Dijkstra算法的类C++伪代码（请勿直接复制粘贴到C++编译器中编译执行），然后再进行讨论：12345678910111213141516171819void Dijkstra_Heap(s) &#123; for(i = 0; i &lt; n; i++) &#123; d[i] = (i == s) ? 0 : INF; // 注释1 &#125; q.push( (d[s], s) ); // 注释2 while( !q.empty() ) &#123; (dist, u) = q.top(); // 注释3 q.pop(); // 注释4 for (e = head[u]; e != INF; e = edge[e].next) &#123; v = edge[e].v; w = edge[e].w; if(d[u] + w &lt; d[v]) &#123; d[v] = d[u] + w; path[v] = u; q.push( (d[v], v) ); &#125; &#125; &#125; &#125; 注释1：初始化s到i的初始最短距离，d[s] = 0 注释2：q即优先队列，这里略去声明是为了将代码简化，让读者能够关注算法本身而不是关注具体实现，push是执行优先队列的插入操作，插入的数据为一个二元组(d[u], u) 注释3：执行优先队列的获取操作，获取的二元组为当前队列中d值最小的 注释4：执行优先队列的删除操作，删除队列顶部的元素（即注释3中d值最小的那个二元组） 以上伪代码中的主体部分竟然没有任何注释，这是因为我要用黑色的字来描述它的重要性，而注释只是注释一些和语法相关的内容。 详细讲解主体代码只有一个循环，这个循环就是遍历了u这个结点的边链表，其中e为边编号，edge[e].w即上文提到的w(u, v)，即u -&gt;v 这条边的权值，而d[u] + w(u, v) &lt; d[v]表示从起点s到u，再经过(u,v)这条边到达v的最短路比之前其它方式到达v的最短路还短，如图二-4-1所示，如果满足这个条件，那么就更新这条最短路，并且利用path数组来记录最短路中每个结点的前驱结点，path[v] = u，表示到达v的最短路的前驱结点为u。 时间复杂度分析以及Dijkstra算法适用范围说明补充一点，这个算法求出的是一棵最短路径树，其中s为根结点，结点之间的关系是通过path数组来建立的，path[v] = u，表明u为v的父结点（树的存储不一定要存儿子结点，也可以用存父结点的方式表示）。 考虑这个算法的复杂度，如果用n表示点数，m表示边数，那么优先队列中最多可能存在的点数有多少？因为我们在把顶点插入队列的时候并没有判断队列中有没有这个点，而且也不能进行这样的判断，因为新插入的点一定会取代之前的点（距离更短才会执行插入），所以同一时间队列中的点有可能重复，插入操作的上限是m次，所以最多有m个点，那么一次插入和删除的操作的平摊复杂度就是O(logm)，但是每次取距离最小的点，对于有多个相同点的情况，如果那个点已经出过一次队列了，下次同一个点出队列的时候它对应的距离一定比之前的大，不需要用它去更新其它点，因为一定不可能更新成功，所以真正执行更新操作的点的个数其实只有n个，所以总体下来的平均复杂度为O((m+n)logm)，而这个只是理论上界，一般问题中都是很快就能找到最短路的，所以实际复杂度会比这个小很多，相比O(n^2)的算法已经优化了很多了。 Dijkstra算法求的是正权图的单源最短路问题，对于权值有负数的情况就不能用Dijkstra求解了，因为如果图中存在负环，Dijkstra带优先队列优化的算法就会进入一个死循环，因为可以从起点走到负环处一直将权值变小。对于带负权的图的最短路问题就需要用到Bellman-Ford算法了。（这将会在下一个博客讲到）]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路算法(1)]]></title>
    <url>%2F2017%2F05%2F25%2Fdijkstra%2F</url>
    <content type="text"><![CDATA[普通dijkstra Dijkstra(O(n²))算法叙述对于一个有向图或无向图，所有边权为正（边用邻接矩阵的形式给出），给定a和b，求a到b的最短路，保证a一定能够到达b。这条最短路是否一定存在呢？答案是肯定的。相反，最长路就不一定了，由于边权为正，如果遇到有环的时候，可以一直在这个环上走，因为要找最长的，这样就使得路径越变越长，永无止境，所以对于正权图，在可达的情况下最短路一定存在，最长路则不一定存在。这里先讨论正权图的最短路问题。 最短路满足最优子结构性质，所以是一个动态规划问题。最短路的最优子结构可以描述为： D(s, t) = {Vs … Vi … Vj … Vt}表示s到t的最短路，其中i和j是这条路径上的两个中间结点，那么D(i, j)必定是i到j的最短路，这个性质是显然的，可以用反证法证明。 基于上面的最优子结构性质，如果存在这样一条最短路D(s, t) = {Vs … Vi Vt}，其中i和t是最短路上相邻的点，那么D(s, i) = {Vs … Vi} 必定是s到i的最短路。Dijkstra算法就是基于这样一个性质，通过最短路径长度递增，逐渐生成最短路。 Dijkstra算法是最经典的最短路算法，用于计算正权图的单源最短路（Single Source Shortest Path，源点给定，通过该算法可以求出起点到所有点的最短路），它是基于这样一个事实：如果源点到x点的最短路已经求出，并且保存在d[x] ( 可以将它理解为D(s, x) )上，那么可以利用x去更新 x能够直接到达的点 的最短路。即： d[y] = min{ d[y], d[x] + w(x, y) } y为x能够直接到达的点，w(x, y) 则表示x-&gt;y这条有向边的边权 具体算法描述如下：对于图G = ，源点为s，d[i]表示s到i的最短路，visit[i]表示d[i]是否已经确定(布尔值)。 1) 初始化 所有顶点 d[i] = INF, visit[i] = false，令d[s] = 0； 2) 从所有visit[i]为false的顶点中找到一个d[i]值最小的，令x = i; 如果找不到，算法结束； 3) 标记visit[x] = true, 更新和x直接相邻的所有顶点y的最短路： d[y] = min{ d[y], d[x] + w(x, y) } （第三步中如果y和x并不是直接相邻，则令w(x, y) = INF） 图的存储以上算法的时间复杂度为O(n^2)，n为结点个数，即每次找一个d[i]值最小的，总共n次，每次找到后对其它所有顶点进行更新，更新n次。由于算法复杂度是和点有关，并且平方级别的，所以还是需要考虑一下点数较多而边数较少的情况，接下来以图一-2-1为例讨论一下边的存储方式。 邻接矩阵是直接利用一个二维数组对边的关系进行存储，矩阵的第i行第j列的值 表示 i -&gt; j 这条边的权值；特殊的，如果不存在这条边，用一个特殊标记来表示；如果i == j，则权值为0。它的优点是实现非常简单，而且很容易理解；缺点也很明显，如果这个图是一个非常稀疏的图，图中边很少，但是点很多，就会造成非常大的内存浪费，点数过大的时候根本就无法存储。图一-2-2展示了图一-2-1的邻接矩阵表示法。 邻接表是图中常用的存储结构之一，每个顶点都有一个链表，这个链表的数据表示和当前顶点直接相邻的顶点（如果边有权值，还需要保存边权信息）。邻接表的优点是对于稀疏图不会有数据浪费，缺点就是实现相对麻烦，需要自己实现链表，动态分配内存。图一-2-3展示了图一-2-1的邻接表表示法。 前向星是以存储边的方式来存储图，先将边读入并存储在连续的数组中，然后按照边的起点进行排序，这样数组中起点相等的边就能够在数组中进行连续访问了。它的优点是实现简单，容易理解，缺点是需要在所有边都读入完毕的情况下对所有边进行一次排序，带来了时间开销，实用性也较差，只适合离线算法。图一-2-4展示了图一-2-1的前向星表示法。 那么用哪种数据结构才能满足所有图的需求呢？这里介绍一种新的数据结构一一链式前向星。 初始化所有的head[i] = INF，当前边总数 edgeCount = 0每读入一条边，调用addEdge(u, v, w)，具体函数的实现如下：1234void addEdge(int u, int v, int w) &#123; edge[ edgeCount ] = EDGE(u, v, w, head[u]); head[u] = edgeCount ++; &#125; 这个函数的含义是每加入一条边(u, v)，就在原有的链表结构的首部插入这条边，使得每次插入的时间复杂度为O(1)，所以链表的边的顺序和读入顺序正好是逆序的。这种结构在无论是稠密的还是稀疏的图上都有非常好的表现，空间上没有浪费，时间上也是最小开销。 调用的时候只要通过head[i]就能访问到由 i 出发的第一条边的编号，通过编号到edge数组进行索引可以得到边的具体信息，然后根据这条边的next域可以得到第二条边的编号，以此类推，直到next域为INF（这里的INF即head数组初始化的那个值，一般取-1即可）。]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Takio的滑板鞋]]></title>
    <url>%2F2017%2F05%2F24%2FTakiodhbx%2F</url>
    <content type="text"><![CDATA[题解，方法：普通dfs 17973 Takio的滑板鞋时间限制:1000MS 内存限制:65535K提交次数:79 通过次数:15 收入:28 题型: 编程题 语言: G++;GCC;VC; Description某一天SCAU_ACM校队的Takio去了第二个城市打比赛这里的人们称它为魅力之都时间过的很快比赛已经打完 他想他必须要离开当他正要走时他看到了一家专卖店那就是他要的滑板鞋他的滑板鞋时尚时尚最时尚 回家的路上他情不自禁摩擦 摩擦在这光滑的地上摩擦 月光下他看到自己的身影有时很远有时很近感到一种力量驱使他的脚步 有了滑板鞋天黑都不怕一步两步一步两步一步一步似爪牙似魔鬼的步伐 Takio想知道他是否能找出一条回家的路径，使得他回家步伐的步长为一步两步一步两步……，若能，Takio则可解锁成就“魔鬼的步伐”。 Details：1.第奇数歩的步长为一步，第偶数歩的步长为两步，步数从1开始，第一步的步长为1，且Takio到家时的最后一步的步长必须为2（回家路径上的步长为1212……12）2.已经过的位置不能再次经过。3.不能经过或踩到障碍上。4.若当前歩的步长为2，则需向同一方向移动两步。 输入格式有多组测试数据（≤20）每组测试数据的第一行是两个正整数n, m（1 &lt;= n, m &lt;= 8），代表平面区域的大小。每组测试数据的第二行到第n + 1行是一个矩阵，代表二维平面的布局，s为Takio现在所在的位置，t为Takio的家，#为障碍，*为可到达区域输入以EOF结束。 输出格式对于每组测试数据，输出一行，若Takio可解锁成就“魔鬼的步伐”则输出”Yes”，否则输出”No”。 输入样例5 7######*#***s*#**#***#t#*#**#*****#* 5 7######*****s*#**#***#t#*#**#*****#* 输出样例NoYes 做题思路这是一道很经典的深搜题，没有用到剪枝是它成为水题的一大原因，下面讲讲思路。首先，我们需要扫图：可以用矩阵来储存（因为边界问题，矩阵需要开大两个单位，不然扫到边界会报错） 扫到#记录是0 扫到*和s和t都记录是1 然后用四个变量记住起点和终点的坐标。（扫图是很关键的，建议自己做完扫图后用输出语句检查自己的矩阵有没有打错）然后我们开始深度搜索，从起点开始往它周围的四个方向各走一步（如果没有障碍），将它走到的位置的坐标和走的步数传去下一个递归里，然后开头加个判断，如果坐标和步数符合终点要求就返回1，然后输出答案，如果不是的话，我们继续开始判断，会不会到了终点可是步数为1，这样我们就要返回0，代表这样走不行。然后我们通过上层递归传过来的步数和位置判断下一步要怎么走，记住，如果我们要走两步，两步都要判断是畅通的，而且两步的方向是不能改变的，再用新到的位置和走的步数进行传递，直到最后递归回来。 PS：记住走过的地方要暂时把点删掉，等递归回来后再把点复原，不然会重复走。至于那个表要怎么打出来，我是这样的，我先用一个while（1）做来回循环，然后最后那里加了一个if（（s=gechar（））==EOF） break；就可以实现不限次读取图了，然后用flag来记录找到路没有，方便打印。 代码1234567#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;using namespace std; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566int x2,y2,t[15][15];int dfs(int x,int y,int b)&#123; int flag=0; if(x==x2&amp;&amp;y==y2&amp;&amp;b==2) return 1; if(x==x2&amp;&amp;y==y2&amp;&amp;b==1) return 0; if(b==2) &#123; if(t[x-1][y]) &#123;t[x-1][y]=0; if(dfs(x-1,y,1)) return 1; t[x-1][y]=1;&#125; if(t[x+1][y]) &#123;t[x+1][y]=0; if(dfs(x+1,y,1)) return 1; t[x+1][y]=1;&#125; if(t[x][y-1]) &#123;t[x][y-1]=0; if(dfs(x,y-1,1)) return 1; t[x][y-1]=1;&#125; if(t[x][y+1]) &#123;t[x][y+1]=0; if(dfs(x,y+1,1)) return 1; t[x][y+1]=1;&#125; &#125; if(b==1) &#123; if(t[x-1][y]&amp;&amp;t[x-2][y]) &#123;t[x-1][y]=0; t[x-2][y]=0; if(dfs(x-2,y,2)) return 1; t[x-1][y]=1; t[x-2][y]=1;&#125; if(t[x+1][y]&amp;&amp;t[x+2][y]) &#123;t[x+1][y]=0; t[x+2][y]=0; if(dfs(x+2,y,2)) return 1; t[x+1][y]=1; t[x+2][y]=1;&#125; if(t[x][y-1]&amp;&amp;t[x][y-2]) &#123;t[x][y-1]=0; t[x][y-2]=0; if(dfs(x,y-2,2)) return 1; t[x][y-1]=1; t[x][y-2]=1;&#125; if(t[x][y+1]&amp;&amp;t[x][y+2]) &#123;t[x][y+1]=0; t[x][y+2]=0; if(dfs(x,y+2,2)) return 1; t[x][y+1]=1; t[x][y+2]=1;&#125; &#125; return 0;&#125;main()&#123; int n,m,i,j,k,l,x1,y1,flag; char s; while(1) &#123; flag=0; memset(t,0,sizeof(t)); scanf("%d%d",&amp;n,&amp;m); getchar(); for(i=1; i&lt;=n; i++) &#123; for(j=1; j&lt;=m; j++) &#123; s=getchar(); if(s=='#') continue; t[i][j]=1; if(s=='s') &#123; x1=i; y1=j; &#125; if(s=='t') &#123; x2=i; y2=j; &#125; &#125; getchar(); &#125; if(t[x1-1][y1]) &#123;t[x1-1][y1]=0; if(dfs(x1-1,y1,1)) flag=1; t[x1-1][y1]=1;&#125; if(!flag) if(t[x1+1][y1]) &#123;t[x1+1][y1]=0; if(dfs(x1+1,y1,1)) flag=1; t[x1+1][y1]=1;&#125; if(!flag) if(t[x1][y1-1]) &#123;t[x1][y1-1]=0; if(dfs(x1,y1-1,1)) flag=1; t[x1][y1-1]=1;&#125; if(!flag) if(t[x1][y1+1]) &#123;t[x1][y1+1]=0; if(dfs(x1,y1+1,1)) flag=1; t[x1][y1+1]=1;&#125; /*for(i=0;i&lt;n;i++) &#123;for(j=0;j&lt;m;j++) printf("%d",t[i][j]); printf("\n"); &#125;*/ if(flag) printf("Yes\n"); else printf("No\n"); if((s=getchar())==EOF) break; &#125;&#125; 写在最后这题只考到了普通dfs，而再深一层就是记忆化dfs了，因为有了记忆化，时间会进一步缩短，当然难度也会大一丢丢。]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>problem solve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2017%2F05%2F23%2Fdpx%2F</url>
    <content type="text"><![CDATA[堆排序实现及讲解 堆排序 代码核心思想其实只要你的程序保证两点，代码就可以正确运行 1.根节点是最大的2.对图中所有的树而言，左子树和右子树是整棵树次大和第三大的数（最重要的） 我想说的是，堆排序已经有一种线段树的思想在里面了，只要加上延迟标记，它就是一棵线段树。 做法大顶堆： 一开始从树的最下方开始对每个节点的子树进行操作，使得左子树和右子树中最大的数和该子树根节点比较，如果是比根节点大的就交换，并且交换后将被换下来的根节点向下做同样操作。 如果是根节点最大，就不用继续向下比较了，因为下面的子树都满足了上述条件。 到达二叉树的根节点之后，将根节点输出，然后将根节点和最后一个节点的数交换，并删除最后一个节点。 对二叉树的根节点做一开始的操作，即：根节点的左右子树选出最大和根节点比较，根节点若比该数更小则交换，同时被向下交换后的根节点就跟它的新左右子树进行同样操作，直到无法操作。 代码1234567#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define rep(i,a,n) for(int i=a; i&lt;n; i++)#define rep1(i,a,n) for(int i=n-1; i&gt;=a; i--)#define s(a) scanf("%d",&amp;a)using namespace std; 123456789101112131415161718192021222324252627282930313233343536int a[100];void down(int x,int n)&#123; int temp=a[x]; int j=x*2+1; while(j&lt;n) &#123; if(j+1&lt;n&amp;&amp;a[j]&lt;a[j+1]) j++; if(a[j]&gt;temp) a[x]=a[j]; else break; x=j; j=x*2+1; &#125; a[x]=temp;&#125;int main()&#123; int n; s(n); rep(i,0,n) s(a[i]); rep1(i,0,n) down(i,n); rep1(i,0,n) &#123; down(0,i+1); rep(j,0,n) printf("%d ",a[j]); printf("\n"); int temp=a[i]; a[i]=a[0]; a[0]=temp; &#125;&#125;]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[差分约束]]></title>
    <url>%2F2017%2F05%2F23%2Fcfys%2F</url>
    <content type="text"><![CDATA[传送门]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小明的密码]]></title>
    <url>%2F2017%2F05%2F22%2Fxmdmm%2F</url>
    <content type="text"><![CDATA[小明的密码题解 小明的密码题型: 编程题 语言: 无限制 问题描述描述小明的密码由N（1&lt;=N&lt;=12）个数字构成，每个数字都可以是0至9中任意一个数字，但小明的密码还有一个特点就是密码中连续的M（1&lt;=M&lt;=4）个数字的和是质数，现给定M和N，求满足条件的密码共有多少个？ 输入格式第1行是T，case数量，此后T行，每行两个数，N和M 输出格式每个case输出一个满足条件的密码总数 输入样例21 12 1 输出样例416 题解1.简单方法：用欧拉筛先找出质数，然后递归12345#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162long v[100]= &#123;0&#125;,prime[50]= &#123;0&#125;,prin=0,n,m,ans,a[20];void Euler()&#123; v[0]=1; v[1]=1; long i,j; for(i=2; i&lt;=100; i++) &#123; if(!v[i]) prime[prin++]=i; for(j=0; j&lt;prin; j++) &#123; if(i*prime[j]&gt;100) break; v[i*prime[j]]=prime[j]; if(!i%prime[j]) break; &#125; &#125;&#125;void solve(long w)&#123; long temp; if(w==n+1) &#123;ans++; return;&#125; if(w&lt;m) for(long i=0; i&lt;=9; i++) &#123; a[w]=i; solve(w+1); &#125; else for(long i=0; i&lt;=9; i++) &#123; temp=0; for(long j=m; j&gt;1; j--) temp+=a[w-j+1]; temp+=i; if(!v[temp]) &#123;a[w]=i; solve(w+1);&#125; &#125; return;&#125;main()&#123; long i,j,casen; scanf("%ld",&amp;casen); Euler(); while(casen--) &#123; ans=0; scanf("%ld%ld",&amp;n,&amp;m); if(m!=1) for(i=0; i&lt;=9; i++) &#123; a[1]=i; solve(2); &#125; else &#123; ans=1; for(i=1; i&lt;=n; i++) ans*=4; &#125; printf("%ld\n",ans); &#125;&#125; 2.用数位dp快速求解 写在最后 其实我们在面对同一道题的时候，往往会有多种解法，在这题里面，因为时间限制给的比较宽松，所以简单的递归就可以解决，当然正解应该是用数位dp。只能说，当你有更简单的方法水过去的时候，不要一开始就码正解。]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>problem solve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海豚加速器破解]]></title>
    <url>%2F2017%2F05%2F19%2Fht%2F</url>
    <content type="text"><![CDATA[海豚加速器破解教程 海豚加速器破解教程 在面对一些国外游戏，或者国内游戏，因为网络问题死活上不了的时候，你也许需要加速器啦~ 可是超级烦的就是，所有加速器都要钱，现在安利一个海豚加速器，当然它也是要钱的，可是现在有破解方法，这个教程会不定时更新。 1.下载海豚加速器2.下载破译软件3.安装完加速器之后，先别运行，解压破译软件，然后把压缩包里的所有东西都放到海豚加速器的根目录下（即与DolphinQ.exe同一个文件夹），然后运行T-T.exe（杀毒要关掉，用管理员身份运行，亲测无毒，因为要修改注册表，所以杀毒软件会判定为有毒）4.打开海豚加速器，输入账号和密码:haituntiyan haituntiyan5.选择喜欢的游戏进行加速，然后尽情游玩吧~ 测试效果：]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MC游戏服加入教程以及安利~]]></title>
    <url>%2F2017%2F05%2F19%2Fmcip%2F</url>
    <content type="text"><![CDATA[加入我们的MC游戏服吧！ MC娱乐服欢迎加入~ 经过一轮的调试和试运行，我们的MC娱乐服已经稳定运行一段时间了，服务器有几大特点 服务器24小时稳定运行 插件全齐，因为是插件服不需要在客户端额外下载mod 插件种类多样，只有你想不到，没有我们做不到的 服务器地图 下面是服务器的截图 流程 下载MC1.8.7纯净版 安装Java（如果安装过了请跳过) 下载MC登录器 运行游戏 选择完中文后，在多人游戏中输入选择添加服务器，输入IP：139.199.186.146 那么就尽情地享受游戏吧~]]></content>
      <categories>
        <category>game</category>
      </categories>
      <tags>
        <tag>game</tag>
        <tag>MC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2017%2F05%2F19%2Fkmp%2F</url>
    <content type="text"><![CDATA[关于KMP算法的next数组 KMP的next数组 一如既往先上代码：123456789void next()&#123; next[1]=0; next[2]=1; i=2; j=1; n=strlen(o); while(i&lt;n) &#123; if(j==0||o[i]==o[j]) &#123;i++; j++; next[i]=j;&#125; else j=next[j]; &#125;&#125; 说明 程序做到了两点: 寻找next数组 用KMP算法自调用 而只要稍加修改就可以用于判断最长字符串，代码如下12345678910while (i &lt; strlen(a) &amp;&amp; j &lt; strlen(user)) &#123; if (a[i] == user[j]) &#123; i++; j++; continue; &#125; else &#123; if (j != 0) j = next[j]; else &#123; i++; j = 1; &#125; &#125; &#125;if (j &gt;= strlen(user)) return i-strlen(user);else return -1;]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邻接表]]></title>
    <url>%2F2017%2F05%2F18%2Fljb%2F</url>
    <content type="text"><![CDATA[简单讲解邻接表 邻接表 看完链式前向星之后，我们来看一下它的小伙伴————邻接表。邻接表相对于普通矩阵记录边和查找边速度会更加快，唯一的不同就是构造起来代码量会更多，下面直接先上代码 123456789101112for(i=1;i&lt;=m;i++) &#123; scanf("%d%d%d",&amp;ui,&amp;vi,&amp;ti); a[ui][0]++;/*ui是起点，这里记录以ui为起点的边的数量*/ a[vi][0]++;/*同上*/ a[ui][a[ui][0]]=i;/*这个是边的编号*/ a[vi][a[vi][0]]=i+m;/*同上*/ l[i+m][1]=ui;/*记录编号为i+m的边的终点*/ l[i+m][2]=ti;/*记录编号为i+m的边的权值*/ l[i][1]=vi;/*同上上*/ l[i][2]=ti;/*同上上*/ &#125; 简介 通过上面的代码我们可以发现，它跟链式前向星真的很像，因为同样是运用了链表的思想，这样做的缺点就是不能用O(1)的时间找到两点之间有没有边，可是这样做dfs和bfs却会比普通矩阵速度要快上不少，为什么呢？因为通常情况下，两个点之间未必会有边的，而对同一个点进行查询，邻接表只需要查O(x)次，x代表当前点所拥有的边，而普通矩阵要查O(n-1)次，n代表点的数量，所以结果出来就显而易见了，对一张图，普通矩阵要查O(n²),而邻接表最多不超过O(n*m)，如果还是不理解，可以看回链式前向星的图表，相信你会理解得更好的~]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链式前向星]]></title>
    <url>%2F2017%2F05%2F17%2Flsqxx%2F</url>
    <content type="text"><![CDATA[简单讲解链式前向星 链式前向星 其实它的主要思想就是用数组建立邻接链表，链式前向星的主要就是下面这几行了1234567void add(int u,int v,int w)&#123; edge[cnt].c= w; edge[cnt].to = v; edge[cnt].next = head[u]; head[u] = cnt++;&#125; 介绍一下第一个出场的是edge.c——权重好的，我们看到紧随其后的是edge.to——这条边的终点/*前两个还是很好理解的然后就是最最大佬的部分，edge.next——它指向同一起点的上一条边我们使用链式前向星时常常会看到这么一条语句for(i=head[u];i;i=e[i].next)//插个介绍，head[u]代表以u为起点的边上一次出现的边的编号我们可以使用它进行一个bfs举个栗子]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
        <tag>data structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教务信息管理系统]]></title>
    <url>%2F2017%2F05%2F16%2Fhomework%2F</url>
    <content type="text"><![CDATA[我的课程设计 课程设计：教务信息管理系统 花了大半个月总算把这个系统做好了，现在放上链接，大概是要windows8.1以上的机子才能正常使用。下载链接：Windows客户端说明:学生账号和密码是从201627010000-201627160000，教师账号密码从1000-9999，管理员分5个：招生，学生，选课，课程的拼音为账号，密码为8个8，还有账号管理员: admin 密码:admin 源码:点这里耐心等待一下网页加载，因为代码量比较大0.0]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>teach</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Something About This Blog]]></title>
    <url>%2F2017%2F05%2F16%2Fsomething-about-this-blog%2F</url>
    <content type="text"><![CDATA[关于本博客和博主的一些小事~ Something About This Blog 本人大一狗，在牛逼哄哄的室友带领下，一起学习怎么建blog，这也是第一篇文章啦，本博客主要用于： 整理知识，学习笔记 发布日记，杂文，所见所想 发布题解 博主竞赛中的经历 2013-10 初次接触Pascal2014-4 初次参加编程类竞赛2015-4 初次在编程类竞赛中获奖（NOIP二等）2016-9 开始接触C语言2017-1 在大学新生赛中获奖（第一）2017-1 开始接触C++2017-4 在大学校赛中获奖（二等）2017-5 在ACM广东省赛中获奖（银奖）2017-10 在CCPC秦皇岛赛区获奖（银奖）2018-4 在大学校赛中获奖（三等）2018-4 在华工校赛中获奖（银奖）2018-5 在ACM广东省赛中获奖（铜奖）至今 学习ing PS:博主这些都是上不了台面的小奖，所以还在认真学习T T 12345int main()&#123; printf("!(give up&amp;&amp;stopped)"); return 0;&#125; 写在最后 博主建起这个blog也不知道会不会持续更新，但是只要有时间就一定会坚持下去。 博主也愿意把自己一些微不足道的小见解和经历分享给大家。（当然多数是用来做题解） 不管怎么样，这blog也算是也是建起来啦~ 在此，本人由衷地说一句：欢迎你的到来！ end]]></content>
      <categories>
        <category>Normal</category>
      </categories>
      <tags>
        <tag>Normal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[How to build this blog?Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>teach</category>
      </categories>
      <tags>
        <tag>Offical</tag>
      </tags>
  </entry>
</search>
